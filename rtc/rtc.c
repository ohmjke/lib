/******************************************************************************/
/**
 * \file        rtc.c
 *
 * \author      Алексей Олехнович <olehnovich@starline.ru>
 *
 * \date        28.12.2015
 *
 * \brief       Переход от числа миллисекунд, прошедших с начала базового года,
 *              к дате, и наоборот
 *
 * \copyright   ООО "НПО "СтарЛайн", 2015. Все права защищены.
 *
 ******************************************************************************/
/******************************************************************************
 *                             ЗАГОЛОВОЧНЫЕ ФАЙЛЫ
 ******************************************************************************/

#include <stddef.h>

#include "rtc.h"

/******************************************************************************
 *                         ЛОКАЛЬНЫЕ МАКРООПРЕДЕЛЕНИЯ
 ******************************************************************************/

#define BASE_YEAR       (2012UL)        // базовый год, должен быть високосным

#if (BASE_YEAR % 4)
#error "Заданный базовый год не является високосным!"
#endif

// дней в "обычном" году, в високосном и в четырех идущих подряд годах
#define DAYS_PER_Y      (365UL)
#define DAYS_PER_LY     (366UL)
#define DAYS_PER_4Y     ((DAYS_PER_Y * 3) + DAYS_PER_LY)

/******************************************************************************
 *                            ЛОКАЛЬНЫЕ ТИПЫ ДАННЫХ
 ******************************************************************************/
/******************************************************************************
 *                              ГЛОБАЛЬНЫЕ ДАННЫЕ
 ******************************************************************************/
/******************************************************************************
 *                              ЛОКАЛЬНЫЕ ДАННЫЕ
 ******************************************************************************/

// дней в первых N месяцах с начала високосного года
static const uint8_t s_days_per_month[12] =
{
    31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
};

/******************************************************************************
 *                         ПРОТОТИПЫ CALLBACK ФУНКЦИЙ
 ******************************************************************************/
/******************************************************************************
 *                         ПРОТОТИПЫ ЛОКАЛЬНЫХ ФУНКЦИЙ
 ******************************************************************************/

static rtc_weekday_t s_weekday_get(rtc_date_t *date);
static bool          s_date_check (rtc_date_t *date);

/******************************************************************************
 *                              ЛОКАЛЬНЫЕ ФУНКЦИИ
 ******************************************************************************/


/** ____________________________________________________________________________ 
  *
  * \brief      Вычисляет день недели на основе года, месяца и числа месяца
  *
  * \param [in] date - указатель на структуру, хранящую текущую дату
  *
  * \return     \ref rtc_weekday_t
  *
  * \retval     ПН = 1, ..., ВС = 7
  *
  * \note       Используется алгоритм "вечного календаря"
  * ____________________________________________________________________________
  */
static rtc_weekday_t s_weekday_get(rtc_date_t *date)
{
    rtc_weekday_t weekday;
    uint32_t      a;
    uint32_t      y;
    uint32_t      m;


    a = (14 - (date->month + 1)) / 12;
    y =  date->year - a;
    m = (date->month + 1) + (12 * a) - 2;

    weekday = (rtc_weekday_t)((7000 + (date->monthday + y + (y / 4) - (y / 100) + (y / 400) + (31 * m) / 12)) % 7);

    // переход к привычной системе, когда
    // неделя начинается с понедельника, а не с ВС
    if ((uint32_t)weekday == 0)
    {
        weekday = RTC_WEEKDAY_SU;
    }

    return weekday;
}


/** ____________________________________________________________________________ 
  *
  * \brief      Проверка корректности даты
  *
  * \param [in] date
  *
  * \return     bool
  * ____________________________________________________________________________
  */
static bool s_date_check(rtc_date_t *date)
{
    bool res = true;


    if (   date->year     < BASE_YEAR
        || date->month    > RTC_MONTH_DEC
        || date->monthday == 0
        || date->monthday > s_days_per_month[date->month]
        || date->hour     > 23
        || date->minute   > 59
        || date->second   > 59
        || date->milsec   > 999)
    {
        res = false;
    }

    return res;
}


/******************************************************************************
 *                             ГЛОБАЛЬНЫЕ ФУНКЦИИ
 ******************************************************************************/


/** ____________________________________________________________________________ 
  *
  * \brief       Вычисляет текущую дату и время через число миллисекунд,
  *              прошедших с начала базового года
  *
  * \param [out] date
  * \param [in]  msec
  *
  * \retval      bool
  * ____________________________________________________________________________
  */
bool rtc_msec_to_date(rtc_date_t *date, uint64_t msec)
{
    uint32_t days;
    uint32_t secs;
    uint32_t i;
    bool     res = false;


    if (date != NULL)
    {
        // конечный результат - число миллисекунд
        date->milsec = msec % 1000;

        // миллисекунды в секунды (дробная часть секунд отбрасывается, её учли выше)
        days = msec / 1000;

        // сохраняем остаток секунд и далее оперируем с днями
        secs = days % (60 * 60 * 24);
        days = days / (60 * 60 * 24);

        // год, предшествующий последнему из високосных.
        // в скобках - сколько лет прошло с начала базового
        // года до начала последнего високосного
        date->year = BASE_YEAR + ((days / DAYS_PER_4Y) * 4);

        // дней с начала последнего високосного года
        days %= DAYS_PER_4Y;

        // если текущий год не високосный
        if (days >= DAYS_PER_LY)
        {
            // переходим к следующему невисокосному за последним високосным
            days -= DAYS_PER_LY;

            i    = days / DAYS_PER_Y;
            days = days % DAYS_PER_Y;

            date->year += i + 1;

            // корректировка, т.к. в s_days_per_month[] в феврале всегда 29 дней
            if (days >= (31 + 28))
            {
                days++;
            }
        }

        // вычисление месяца
        for (i = 0; days >= s_days_per_month[i]; i++)
        {
            days -= s_days_per_month[i];
        }
        date->month = i;

        // число
        date->monthday = days + 1;

        date->hour   =  secs / 3600;
        date->minute = (secs % 3600) / 60;
        date->second =  secs % 60;

        date->weekday = s_weekday_get(date);

        res = true;
    }

    return res;
}


/** ____________________________________________________________________________ 
  *
  * \brief       Вычисляет число миллисекунд, прошедших с начала базового
  *              года, на основе текущих даты и времени
  *
  * \param [in]  date
  * \param [out] msec
  *
  * \return      bool
  * ____________________________________________________________________________
  */
bool rtc_date_to_msec(rtc_date_t *date, uint64_t *msec)
{
    uint32_t temp;
    uint32_t days;
    bool     res = false;


    if (s_date_check(date))
    {
        // число полных лет с начала базового года
        temp = date->year - BASE_YEAR;

        // дней с начала базового года до последнего из високосных
        days = (temp / 4) * DAYS_PER_4Y;

        // полных лет с начала последнего високосного года
        temp %= 4;

        // если текущий год не високосный
        if (temp != 0)
        {
            days += DAYS_PER_LY + (DAYS_PER_Y * (temp - 1));

            // корректировка, т.к. в s_days_per_month[] в феврале всегда 29 дней
            if (date->month > RTC_MONTH_FEB)
            {
                days--;
            }
        }

        for (temp = 0; temp < date->month; temp++)
        {
            days += s_days_per_month[temp];
        }

        days += (date->monthday - 1);

        days = (days * 24) + date->hour;
        days = (days * 60) + date->minute;
        days = (days * 60) + date->second;

        *msec = ((uint64_t)days * 1000) + date->milsec;

        res = true;
    }

    return res;
}


/******************************************************************************
 *                              CALLBACK ФУНКЦИИ
 ******************************************************************************/
/******************************************************************************
 *                           ОБРАБОТЧИКИ ПРЕРЫВАНИЙ
 ******************************************************************************/
/******************************************************************************
 *                                 КОНЕЦ ФАЙЛА
 ******************************************************************************/

